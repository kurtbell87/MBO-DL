# oracle_labeler + trajectory_builder — TDD Spec

## Summary

Two C++ modules:
1. **oracle_labeler** — Stateless per-call function that generates ground-truth action labels using future price data (lookahead oracle).
2. **trajectory_builder** — Manages position state and entry price, sequences oracle calls, produces `(window, label)` training pairs.

## oracle_labeler

### Signature

```cpp
int oracle_label(
    const std::vector<BookSnapshot>& snapshots,
    int t,
    int position_state,          // -1, 0, +1
    float entry_price,           // mid_price at entry; NaN if flat
    int horizon = 100,           // 10 seconds forward (100 snapshots)
    int target_ticks = 10,       // 2.50 points entry threshold
    int stop_ticks = 5,          // 1.25 points stop loss
    int take_profit_ticks = 20,  // 5.00 points take profit
    float tick_size = 0.25f
);
```

### Action Space

| Action | ID | Meaning |
|--------|----|---------|
| Hold | 0 | No-op |
| Enter Long | 1 | Buy (flat → long) |
| Enter Short | 2 | Sell (flat → short) |
| Exit | 3 | Close (long/short → flat) |
| Reverse | 4 | Never generated by oracle |

### Logic

**When flat (position_state == 0)**:
- Assert `entry_price` is NaN
- Scan forward `horizon` snapshots from `t`
- Track `(mid_price[t+k] - mid_price[t]) / tick_size` in ticks
- If price hits `+target_ticks` before `-stop_ticks` → ENTER_LONG (1)
- If price hits `-target_ticks` before `+stop_ticks` → ENTER_SHORT (2)
- If neither threshold hit → HOLD (0)

**When in position (position_state != 0)**:
- Assert `entry_price` is NOT NaN
- `direction = position_state` (+1 for long, -1 for short)
- Scan forward `horizon` snapshots:
  - `future_pnl_ticks = direction * (mid_price[t+k] - entry_price) / tick_size`
  - If `future_pnl_ticks >= take_profit_ticks` → EXIT (3)
  - If `future_pnl_ticks <= -stop_ticks` → EXIT (3)
- If neither hit → HOLD (0)

### Post-condition Assertions
- Oracle never returns ENTER (1 or 2) when `position_state != 0`
- Oracle never returns EXIT (3) when `position_state == 0`
- Oracle never returns REVERSE (4)

## trajectory_builder

### API

```cpp
struct TrainingSample {
    std::vector<std::array<float, 194>> window;  // W=600 encoded features
    int label;                                     // 0-4
};

std::vector<TrainingSample> build_trajectory(
    const std::vector<BookSnapshot>& snapshots,
    int horizon = 100,
    int target_ticks = 10,
    int stop_ticks = 5,
    int take_profit_ticks = 20,
    float tick_size = 0.25f
);
```

### Trajectory Logic

```
t_start = W - 1 = 599
t_stop  = len(snapshots) - horizon - 1 (inclusive)
Assert: len(snapshots) >= W + horizon (= 700 minimum)

For each t from t_start to t_stop:
  1. Build observation window [t-W+1 : t+1] (exactly W snapshots)
  2. Inject current position_state into feature encoding
  3. Call oracle_label(snapshots, t, position_state, entry_price, ...)
  4. Update state:
     - Label 1 (ENTER_LONG): position_state = +1, entry_price = mid_price[t]
     - Label 2 (ENTER_SHORT): position_state = -1, entry_price = mid_price[t]
     - Label 3 (EXIT): position_state = 0, entry_price = NaN
     - Label 0 (HOLD): no change
  5. Store (encoded_window, label) pair
```

### Subsampling

After building the full trajectory, subsample N_overfit windows (default 32).

**Label distribution checks on subsample**:
- At least 3 of 4 classes (0, 1, 2, 3) present
- No single class exceeds 80%
- Class 4 (REVERSE) never present

## Dependencies

- `book_builder.hpp` (BookSnapshot)
- `feature_encoder.hpp` (encode_window, constants)
- C++20, GTest

## File Layout

```
src/
  oracle_labeler.hpp       # oracle_label function declaration + action enum
  oracle_labeler.cpp       # Implementation
  trajectory_builder.hpp   # TrainingSample struct + build_trajectory declaration
  trajectory_builder.cpp   # Implementation
tests/
  oracle_labeler_test.cpp       # Unit tests
  trajectory_builder_test.cpp   # Unit tests
```

## Test Cases

### oracle_labeler tests

1. **Flat + price rises to target → ENTER_LONG** — Synthetic snapshots where mid_price rises by target_ticks within horizon. Verify returns 1.
2. **Flat + price falls to target → ENTER_SHORT** — Mid_price drops by target_ticks. Verify returns 2.
3. **Flat + price hits stop before target → HOLD** — Price moves down by stop_ticks before reaching target_ticks up. Verify returns 0.
4. **Flat + no threshold hit → HOLD** — Price stays within both thresholds for entire horizon. Verify returns 0.
5. **Long + take profit hit → EXIT** — In long position, future PnL reaches take_profit_ticks. Verify returns 3.
6. **Long + stop loss hit → EXIT** — In long position, future PnL reaches -stop_ticks. Verify returns 3.
7. **Long + hold** — In long position, PnL stays between stop and take-profit. Verify returns 0.
8. **Short + take profit hit → EXIT** — In short position, price drops enough for take_profit_ticks PnL. Verify returns 3.
9. **Short + stop loss hit → EXIT** — In short position, price rises by stop_ticks from entry. Verify returns 3.
10. **Never returns REVERSE** — Exhaustive check that no test case returns 4.
11. **Precondition: flat requires NaN entry_price** — Verify assertion fires if position_state=0 but entry_price is valid.
12. **Precondition: in-position requires valid entry_price** — Verify assertion fires if position_state!=0 but entry_price is NaN.
13. **Horizon boundary** — Verify `t + horizon <= snapshots.size()` is required.

### trajectory_builder tests

14. **Minimum snapshot count** — Fewer than W + horizon snapshots raises error.
15. **Trajectory length** — Verify correct number of samples: `len(snapshots) - horizon - W + 1`.
16. **Position state transitions** — Feed snapshots that should trigger ENTER_LONG then EXIT. Verify position_state transitions in the labels.
17. **Entry price tracking** — After ENTER_LONG, verify subsequent oracle calls use the correct entry_price.
18. **Window size** — Every sample's window has exactly W=600 encoded features.
19. **Feature dim** — Every feature vector in every window has exactly 194 elements.
20. **Position state in features** — After ENTER_LONG, the position_state feature (index 193) in subsequent windows should be +1.0.
21. **Labels are valid** — All labels in {0, 1, 2, 3}. No label == 4.
22. **Flat start** — First oracle call starts with position_state=0 and entry_price=NaN.
